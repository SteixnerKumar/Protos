/*
 *	THINC Lab at UGA | Cyber Deception Group
 *
 *	Author: Aditya Shinde
 * 
 *	email: shinde.aditya386@gmail.com
 */
package thinclab.spuddx_parser;

import java.io.FileInputStream;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.TokenStream;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import thinclab.RandomVariable;
import thinclab.env.Environment;
import thinclab.env.SamplingBasedPOEnvironment;
import thinclab.legacy.DD;
import thinclab.legacy.DDleaf;
import thinclab.legacy.DDnode;
import thinclab.legacy.Global;
import thinclab.legacy.OP;
import thinclab.models.ActionDBN;
import thinclab.utils.Tuple;

/*
 * @author adityas
 *
 */
public class SpuddXParserWrapper {

	/*
	 * Wrapper for SPUDDX wrapper generated by ANTLR4. Implements the visitor
	 * methods for each statement.
	 */

	private String fileName;
	private SpuddXParser parser;

	private static final Logger LOGGER = LogManager.getLogger(SpuddXParserWrapper.class);

	// -------------------------------------------------------------------------
	// Implementation of ANTLR4 visitors

	private class DDParser extends SpuddXBaseVisitor<DD> {

		private HashMap<String, DD> declaredDDs;

		public DDParser(HashMap<String, DD> declaredDDs) {

			super();
			this.declaredDDs = declaredDDs;
		}

		@Override
		public DD visitDDDecl(SpuddXParser.DDDeclContext ctx) {

			// Prepare root DD
			String varName = ctx.variable_name().IDENTIFIER().getText();
			int varIndex = Global.varNames.indexOf(varName);
			var valNames = Global.valNames.get(varIndex);

			// Prepare children
			var ddChildVisitor = new DDChildVisitor(this.declaredDDs);
			var childDDList = ctx.dd_child().stream().map(ddChildVisitor::visit).collect(Collectors.toList());

			// Check if
			DD[] children = new DD[childDDList.size()];
			for (var child : childDDList) {

				int childIndex = valNames.indexOf(child.first());

				if (childIndex < 0 || child.second() == null) {

					LOGGER.error("Could not parse DD for child " + child.first());
					System.exit(-1);
				}

				children[childIndex] = child.second();
			}

			if (childDDList.size() != Global.varDomSize.get(varIndex))
				LOGGER.error("Error while parsing DD");

			return OP.reorder(DDnode.getDD(varIndex + 1, children));
		}

		@Override
		public DD visitDDleaf(SpuddXParser.DDleafContext ctx) {

			return DDleaf.getDD(Float.valueOf(ctx.dd_leaf().FLOAT_NUM().getText()));
		}

		@Override
		public DD visitSameDD(SpuddXParser.SameDDContext ctx) {

			return ActionDBN.getSameTransitionDD(ctx.same_dd_decl().variable_name().getText());
		}

		@Override
		public DD visitDDRef(SpuddXParser.DDRefContext ctx) {

			String ddName = ctx.dd_ref().dd_name().IDENTIFIER().getText();

			if (this.declaredDDs.containsKey(ddName))
				return this.declaredDDs.get(ddName);

			else {

				LOGGER.error(String.format("DD named %s not defined.", ddName));
				return null;
			}
		}

		@Override
		public DD visitAtomicExpr(SpuddXParser.AtomicExprContext ctx) {

			return this.visit(ctx.dd_decl());
		}

		@Override
		public DD visitParenExpr(SpuddXParser.ParenExprContext ctx) {

			return this.visit(ctx.dd_expr());
		}

		@Override
		public DD visitMultDivExpr(SpuddXParser.MultDivExprContext ctx) {

			var left = this.visit(ctx.left);
			var right = this.visit(ctx.right);

			if (ctx.op.getText().contentEquals("*"))
				return OP.mult(left, right);

			else if (ctx.op.getText().contentEquals("/"))
				return OP.div(left, right);

			else
				return null;
		}

		@Override
		public DD visitAddSubExpr(SpuddXParser.AddSubExprContext ctx) {

			var left = this.visit(ctx.left);
			var right = this.visit(ctx.right);

			if (ctx.op.getText().contentEquals("+"))
				return OP.add(left, right);

			else if (ctx.op.getText().contentEquals("-"))
				return OP.sub(left, right);

			else
				return null;
		}

		@Override
		public DD visitNegExpr(SpuddXParser.NegExprContext ctx) {

			var term = this.visit(ctx.dd_expr());

			if (ctx.op.getText().contentEquals("+"))
				return term;

			else if (ctx.op.getText().contentEquals("-"))
				return OP.neg(term);

			else
				return null;
		}

	}

	private class DDChildVisitor extends SpuddXBaseVisitor<Tuple<String, DD>> {

		public HashMap<String, DD> declaredDDs;

		public DDChildVisitor(HashMap<String, DD> declaredDDs) {

			super();
			this.declaredDDs = declaredDDs;
		}

		@Override
		public Tuple<String, DD> visitDd_child(SpuddXParser.Dd_childContext ctx) {

			String childName = ctx.var_value().IDENTIFIER().getText();
			var childDD = new DDParser(this.declaredDDs).visit(ctx.dd_decl());

			return new Tuple<String, DD>(childName, childDD);
		}
	}

	private class DDDeclsVisitor extends SpuddXBaseVisitor<HashMap<String, DD>> {

		public HashMap<String, DD> declaredDDs;

		public DDDeclsVisitor(HashMap<String, DD> declaredDDs) {

			super();
			this.declaredDDs = declaredDDs;
		}

		@Override
		public HashMap<String, DD> visitDd_decls(SpuddXParser.Dd_declsContext ctx) {

			String ddName = ctx.dd_name().IDENTIFIER().getText();
			var parsedDD = new DDParser(this.declaredDDs).visit(ctx.dd_expr());

			LOGGER.debug(String.format("Parsed DD %s - %s", ddName, parsedDD));
			this.declaredDDs.put(ddName, OP.reorder(parsedDD));

			return this.declaredDDs;
		}
	}

	private class CPDDefVisitor extends SpuddXBaseVisitor<Tuple<String, DD>> {

		private HashMap<String, DD> declaredDDs;

		public CPDDefVisitor(HashMap<String, DD> declaredDDs) {

			super();
			this.declaredDDs = declaredDDs;
		}

		@Override
		public Tuple<String, DD> visitCpd_def(SpuddXParser.Cpd_defContext ctx) {

			String varName = ctx.variable_name().IDENTIFIER().getText();
			DD dd = new DDParser(this.declaredDDs).visit(ctx.dd_decl());

			return new Tuple<String, DD>(varName, dd);
		}

	}

	private class ActionDBNDef extends SpuddXBaseVisitor<ActionDBN> {

		private HashMap<String, DD> declaredDDs;

		public ActionDBNDef(HashMap<String, DD> declaredDDs) {

			super();
			this.declaredDDs = declaredDDs;
		}

		public ActionDBN visitActiondbn_def(SpuddXParser.Actiondbn_defContext ctx) {

			var actions = ctx.actions().IDENTIFIER().stream().map(i -> i.getText()).collect(Collectors.toList());

			var cpdParser = new CPDDefVisitor(this.declaredDDs);
			HashMap<String, DD> transitions = new HashMap<>(10);

			ctx.cpd_def().stream().map(cpdParser::visit).forEach(t -> transitions.put(t.first(), t.second()));

			DD[] transitionDDs = new DD[Global.varNames.size() / 2];
			LOGGER.debug("Checking for " + Global.varNames);

			for (int i = 0; i < transitionDDs.length; i++) {

				if (transitions.containsKey(Global.varNames.get(i)))
					transitionDDs[i] = transitions.get(Global.varNames.get(i));

				else
					transitionDDs[i] = ActionDBN.getSameTransitionDD(Global.varNames.get(i));
			}

			return new ActionDBN(actions, transitionDDs);
		}
	}

	private class EnvDefVisitor extends SpuddXBaseVisitor<Environment> {

		private HashMap<String, DD> declaredDDs;

		public EnvDefVisitor(HashMap<String, DD> declaredDDs) {

			super();
			this.declaredDDs = declaredDDs;
		}

		@Override
		public Environment visitEnv_def(SpuddXParser.Env_defContext ctx) {

			var env = new SamplingBasedPOEnvironment();
			var actionDBNVisitor = new ActionDBNDef(this.declaredDDs);

			ctx.actiondbn_def().stream().map(actionDBNVisitor::visit)
					.forEach(d -> env.addDynamicsForAction(d.jointActionSequence, d));

			return env;
		}

	}

	// -------------------------------------------------------------------------

	public SpuddXParserWrapper(String fileName) {

		this.fileName = fileName;

		try {

			// Get tokens from lexer
			InputStream is = new FileInputStream(this.fileName);
			ANTLRInputStream antlrIs = new ANTLRInputStream(is);
			SpuddXLexer lexer = new SpuddXLexer(antlrIs);
			TokenStream tokens = new CommonTokenStream(lexer);

			this.parser = new SpuddXParser(tokens);

		}

		catch (Exception e) {

			LOGGER.error(String.format("Error while trying to parse %s: %s", this.fileName, e));
			System.exit(-1);
		}
	}
	
	public List<RandomVariable> getVariableDeclarations() {
		
		this.parser.reset();
		return new VariablesDeclarationVisitor().visit(this.parser.domain());
	}

}
